\section{Definicja problemu, framework}
% TODO
% definicje wstępne:
% - z jakich nazw zmiennych będziemy korzystać
% - czym jest DFA
% - czym są próbki

\begin{definition}[Deterministyczny automat skończony (DFA)]
Deterministyczny automat skończony (DFA) to szóstka uporządkowana $(Q, \Sigma, \delta, q_\lambda, \mathbb{F_A}, \mathbb{F_R})$, gdzie:
\begin{itemize}
    \item $Q$ to skończony zbiór stanów,
    \item $\Sigma$ to skończony alfabet wejściowy,
    \item $\delta: Q \times \Sigma \to Q$ to funkcja przejścia,
    \item $q_\lambda \in Q$ to stan początkowy,
    \item $\mathbb{F_A} \subseteq Q$ to zbiór stanów akceptujących,
    \item $\mathbb{F_R} \subseteq Q$ to zbiór stanów odrzucających.
\end{itemize}
\end{definition}


\subsection{Definicja problemu}

\begin{definition}[Problem naprawienia częściowego DFA]
    
    \textbf{Wejście:} częściowy automat deterministyczny $A = (Q, \Sigma, \delta, q_\lambda, \mathbb{F_A}, \mathbb{F_R})$, w którym:
\begin{itemize}
    \item niektóre krawędzie w automacie mogły zostać usunięte, więc dla niektórych par $(q, a) \in Q \times \Sigma$ funkcja $\delta$ nie jest określona,
    \item niektóre stany $q \in Q$ mogły zostać usunięte z automatu (brakujące stany), więc nie należą one ani do $\mathbb{F_A}$, ani do $\mathbb{F_R}$,
\end{itemize}
oraz zbiory próbek $S^+ \subseteq \Sigma^{*}$ (słowa akceptowane) i $S^{-} \subseteq \Sigma^{*}$ (słowa odrzucane).

\vspace{0.5cm}

\noindent \textbf{Wyjście:} odpowiedź, czy istnieje uzupełnienie brakujących przejść, klasyfikacji stanów i ewentualne dodanie stanów tak, aby otrzymany automat był deterministyczny, posiadał najmniejszą możliwą liczbę stanów oraz akceptował wszystkie słowa z $S^+$ i odrzucał wszystkie słowa z $S^-$. W przypadku istnienia, należy podać takie uzupełnienie.

\end{definition}


\subsection{Trywialność przypadku brakujących stanów}
W rozważanej wersji problemu dopuszczamy dodawanie brakujących stanów. Jest to jednak przypadek trywialny, bo możemy ograniczyć maksymalną liczbę stanów w automacie do liczby stanów w drzewie prefiksowym zbudowanym z próbek - jeżeli automat jest naprawialny, to będzie to automat rozwiązujący problem. Rozmiar takiego drzewa możemy ograniczyć przez $N = |S^+ \cup S^-| \cdot \max_{w \in S^+ \cup S^-} |w|$. Możemy więc dla każdej liczby stanów $n$ w zakresie $[1, N]$ sprawdzać, czy istnieje naprawa automatu z dokładnie $n$ stanami; od pewnej wartości $n$ odpowiedź staje się pozytywna, co pozwala użyć wyszukiwania binarnego bez istotnej zmiany (i tak wykładniczej) złożoności. 

Dlatego w dalszej części pracy zakładamy, że liczba stanów jest ustalona i nie rozważamy dodawania nowych.

\subsection{Definicja problemu (uproszczona)}

\begin{definition}[Problem naprawienia częściowego DFA (uproszczony)]
\textbf{Wejście:} częściowy automat deterministyczny $A = (Q, \Sigma, \delta, q_\lambda, \mathbb{F_A}, \mathbb{F_R})$, w którym dla pewnych par $(q, a) \in Q \times \Sigma$ funkcja $\delta$ nie jest określona, oraz zbiory próbek $S^+ \subseteq \Sigma^{*}$ i $S^{-} \subseteq \Sigma^{*}$. Liczba stanów $|Q|$ jest ustalona.
\vspace{0.3cm}

\noindent \textbf{Wyjście:} odpowiedź, czy istnieje uzupełnienie brakujących przejść i klasyfikacji stanów tak, aby otrzymany automat był deterministyczny, akceptował wszystkie słowa z $S^+$ i odrzucał wszystkie słowa z $S^-$. W przypadku istnienia należy podać takie uzupełnienie.
\end{definition}

\section{NP-zupełność}
% TODO
% Definicja NP zupełności


\subsection{Przynależność do NP}
% TODO


\subsection{NP-trudność}
% TODO
% Problem pasywnego uczenia to najogólniejszy przypadek naszego problemu (kiedy nie znamy żadnych przejść)



\section{FPT}
% TODO: explain what is FPT, W[1], W[2], W[P] - short intro; references to parametrized complexity book/papers?

\subsection{W[1]-trudność}

\begin{definition}[Problem klik]
\textbf{Wejście:} graf nieskierowany $G = (V, E)$.

\noindent \textbf{Wyjście:} klika w grafie $G$, czyli podzbiór wierzchołków $V' \subseteq V$ taki, że dla każdej pary wierzchołków $u, v \in V'$ zachodzi $(u, v) \in E$.

\noindent Problem kliki należy do problemów NP-zupełnych. 
\end{definition}


\begin{definition}[Problem k-klik]
\noindent Problem k-klik to zparametryzowana (\textit{Fixed Parameter Traceability}) wersja problemu kliki, w której dodatkowo podana jest liczba całkowita $k$ i należy odpowiedzieć, czy w grafie istnieje klika o rozmiarze co najmniej $k$.

\noindent\textbf{Wejście:} graf nieskierowany $G = (V, E)$ oraz liczba całkowita $k$.

\noindent \textbf{Wyjście:} odpowiedź, czy w grafie $G$ istnieje kliką o rozmiarze co najmniej $k$, czyli podzbiór $V' \subseteq V$ taki, że $|V'| \geq k$ oraz dla każdej pary wierzchołków $u, v \in V'$ zachodzi $(u, v) \in E$.

\noindent Problem k-klik należy do klasy W[1]-zupełnych problemów.
% TODO: link to source/reference
\end{definition}

Pokażemy, jak dla dowolnego wejścia do problemu k-klik skonstruować automat oraz próbki, będące wejściem do problemu naprawienia częściowego DFA, tak aby rozwiązanie problemu naprawienia częściowego DFA istniało wtedy i tylko wtedy, gdy w grafie istnieje klika o rozmżemy, jak dla dowolnego wejścia do problemu k-klik skonstruować automat oraz próbki, będące wejściem do problemu naprawienia częściowego DFA, tak aby rozwiązanie problemu naprawienia częściowego DFA istniało wtedy i tylko wtedy, gdy w grafie istnieje klika o rozmiarze co najmniej $k$. Dodatkowo pokażemy jak z rozwiązanego problemu naprawienia częściowego DFA wyprowadzić rozwiązanie problemu k-klik.

% TODO: explain used syntax: [abc] means word sample from letters a,b,c; V_i means i-th vertex in graph, v_i means state corresponding to V_i, etc 

\subsubsection{Dla $|\Sigma|=O(n)$}
% TODO add complexity - time, memory, etc

Na rysunku \ref{fig:kcliquen-v2} przedstawiona jest konstrukcja automatu dla redukcji z k-klik, korzystająca z alfabetu o rozmiarze zależnym od liczby wierzchołków grafu. \\
Każdy stan $q_{\lambda}$ odpowiada temu samemu stanowi początkowemu automatu.
Przejścia $p_i$ oznaczone przerywaną linią odpowiadają brakującym przejściom w automacie. Każde przejście, które nie jest zaznaczone i nie wychodzi ze stanu $sink_+$ lub $sink_-$, prowadzi do stanu odrzucającego $\text{sink}_-$. Niezaznaczone przejścia wychodzące ze stanów $\text{sink}_+$ i $\text{sink}_-$ prowadzą do tych samych stanów. \\
Część automatu zaznaczona ramką jest powielana dla każdego stanu $v_.$. \\

\import{theory/figures}{reduction_kclique_n_v2}

\noindent Idea konstrukcji: \\

Chcemy aby krawędzie $p_.$ prowadziły do stanów $v_.$. Jeżeli krawędź $p_x$ prowadzi do stanu $v_i$, interpretujemy to jako wybranie wierzchołka $V_i$ jako $x$-ty wierzchołek w klice. \\

\begin{equation}
\forall x\in\{1..k\}\ \exists i\in\{1..n\} \ \delta(q_{\lambda},p_x)=v_i
\label{eq:kclique-vi}
\end{equation}

Do tej samej kliki nie możemy wybrać tego samego wierzchołka wielokrotnie, więc musimy zagwarantować, że dla różnych przejść $p_x$ i $p_y$ wybieramy różne stany $v_i$ i $v_j$. \\

\begin{equation}
\forall (x, y \in \{1..k\} \land x \neq y) \ \forall i, j \in \{1..n\} \ (\delta(q_{\lambda}, p_x) = v_i \land \delta(q_{\lambda}, p_y) = v_j) \implies i \neq j
\label{eq:kclique-diff}
\end{equation}

Dodatkowo musimy zagwarantować, że wybrane wierzchołki tworzą klikę, czyli że każdy wybrany wierzchołek jest połączony z każdym innym wybranym wierzchołkiem. \\

\begin{equation}
\forall (x, y \in \{1..k\} \land x \neq y) \ \forall{i, j \in \{1..n\}} \ (\delta(q_{\lambda}, p_x) = v_i \land \delta(q_{\lambda}, p_y) = v_j) \implies (v_i, v_j) \in E
\label{eq:kclique-clique}
\end{equation}

% TODO: explain the concept/intuition behind the construction - how is it supposed to work

%* zagwarantowanie że wybieramy stany v_i
\noindent \textbf{Gwarancja prowadzenia brakujących krawędzi $p_x$ do wierzchołków $v_i$}

Zagwarantowanie tego faktu opiera się na prostej obserwacji: jedyne krawędzie $t$, które nie prowadzą do stanu odrzucającego, znajdują się za wierzchołkami $v_i$. Oznacza to, że aby próbka mogła zostać zaakceptowana, musimy przejść przez krawędź $p_x$ do któregoś ze stanów $v_i$, a następnie przez krawędź $t$ do stanu akceptującego. W przeciwnym wypadku, w trakcie przechodzenia próbką po automacie, trafimy do stanu $\text{sink}_-$, więc próbka zostanie odrzucona.\\
W takim przypadku, aby zagwarantować przejście krawędzią $p_x$ do któregoś ze stanów $v_i$, dodajemy w każdej próbce literę $t$ zaraz po literze $p_x$.

Jedynym wyjątkiem jest stan $\text{sink}_+$. 
Wychodząca z niego krawędź $t$ musi też prowadzić do $\text{sink}_+$ - w przeciwnym wypadku próbki \eqref{eq:kclique-n-clique} zostaną odrzucone gdy $p_x, p_y, v_i, v_j$ takich, że $(i, j) \notin E \implies \exists z \in \{1..n\} v_z = \delta(q_{\lambda}, p_x) \land z \neq i$, ponieważ ze stanu $v_z$ przejdziemy wtedy w automacie krawędzią $t$ a następnie $e_i$, a $z \neq i \implies \delta(\delta(v_z, t), e_i) = \text{sink}_+$. Ta próbka nie oznacza niepoprawnego przypisana krawędzi (więc powinna zostać zaakceptowana), a wiemy że w naszej próbce występuje jeszcze jedno przejście krawędzią $t$, więc musi ono prowadzić do stanu $\text{sink}_+$. \\
Możemy ten problem rozwiązać na 2 sposoby. Korzystając z faktu, że w próbce \eqref{eq:kclique-n-clique} są dokładnie 2 wystąpienia krawędzi $t$, możemy stworzyć alternatywny $\text{sink}_+$ (składający się z 2 stanów), który po pierwszym przejściu krawędzią $t$ prowadzi do drugiego stanu $\text{sink}_+$, a po drugim przejściu krawędzią $t$ prowadzi do stanu odrzucajcego $\text{sink}_-$. \\
Alternatywną metodą jest odrzucenie prowadzenie krawędzi $p_x$ do stanu $\text{sink}_+$ poprzez dodanie próbek odrzucających, które wymuszają prowadzenie krawędzi $p_x$ do stanu odrzucajcego:

\begin{equation}
\forall x\in\{1..k\} \ {[p_x] \in S^-}
\label{eq:kclique-n-sink}
\end{equation}

%* zagwarantowanie że wybrane stany v_i są różne
\noindent \textbf{Wybór różnych stanów $v_i$ dla różnych przejść $p_x$}

Aby uniemożliwić wybór tego samego $v_i$ dla różnych przejść $p_x$ oraz $p_y$ wystarczy stworzyć próbki postaci: 

\begin{equation}
\forall (x, y \in \{1..k\} \land x \neq y) \ \forall i \in \{1..n\} \ {[p_x \ t \ e_i \ c_1 \ p_y \ t \ e_i \ c_1]  \in S^+}
\label{eq:kclique-n-diff}
\end{equation}

W ten sposób, jeżeli oba przejścia $p_x$ i $p_y$ prowadziłyby do tego samego stanu $v_i$, to po pierwszym przejściu krawędziami $t \ e_i c_1$ trafilibyśmy do stanu $q_{\lambda}$, a następnie po drugim przejściu krawędziami $t \ e_i$ trafilibyśmy do stanu odrzucajcego $q_{\lambda}$, więc próbka zostałaby odrzucona. \\
Jeżeli jednak przejścia $p_x$ i $p_y$ prowadzą do różnych stanów $v_i$ i $v_j$, to pierwsze lub drugie przejście krawędziami $t \ e_i$ doprowadzi do stanu $q_{\lambda}$, a następnie przejście krawędzią $c_1$ doprowadzi do stanu akceptującego $\text{sink}_+$, więc próbka zostanie zaakceptowana.

%* zagwarantowanie że wybrane wierzchołki tworzą klikę
\noindent \textbf{Gwarancja, że wybrane wierzchołki tworzą klikę}
Aby zagwarantować, że wybrane wierzchołki tworzą klikę, tworzymy próbki wymuszające sąsiedztwo wybranych wierzchołków:

\begin{equation}
\forall (x, y \in \{1..k\} \land x \neq y) \ \forall{i, j \in \{1..n\}} \ [p_x \ t \ e_i \ c_1 \ p_y \ t \ e_j \ c_2 \ e_i] \in S^+
\label{eq:kclique-n-clique}
\end{equation}

%! FIXME: wypadałoby się upewnić że wszędzie gdzie miałem napisać STAN (w automacie) to napisałem stan, a tam gdize miałem napisać WIERZCHOŁEK (w grafie) to napisałem wierzchołek

Jeżeli dany stan nie sprawdza wyboru wierzchołków $V_i$ lub $V_j$ w grafie, to któraś z wybranych krawędzi $p_x$ lub $p_y$ nie prowadzi do stanu $v_i$ lub $v_j$. Wtedy przejście krawędziami $t \ e_i$ lub $t \ e_j$ doprowadzi do stanu akceptującego $\text{sink}_+$. \\
Jeżeli mamy jednak sytuację, w której $\delta(q_{\lambda}, p_x) = v_i$ oraz $\delta(q_{\lambda}, p_y) = v_j$, to przejście krawędziami $t \ e_i$ doprowadzi do stanu $u_i$, skąd krawędzią $c_1$ trafimy do $q_{\lambda}$. 
Przejście krawędziami $t \ e_j$ doprowadzi do stanu $u_j$. Ze stanu $u_j$ przejście krawędziami $c_2 \ e_i$ doprowadzi do stanu akceptującego tylko wtedy, gdy w oryginalnym grafie istnieje krawędź $(v_j, v_i) \in E$. W przeciwnym wypadku przejście krawędziami $c_2 \ e_i$ doprowadzi do stanu odrzucającego. \\

\subsubsection{Dla $|\Sigma|=3$}

Aby zredukować liczbę potrzebnych liter z $|\Sigma|=O(n)$ do $|\Sigma|=3$, możemy zakodować każdą literę z oryginalnego alfabetu jako unikalny ciąg liter z alfabetu 2-literowego (rysunek \ref{fig:kclique3}). W tym celu możemy użyć kodowania binarnego, gdzie każda litera z oryginalnego alfabetu jest reprezentowana jako ciąg liter '0' i '1' o długości $\lceil \log_2(n) \rceil$, gdzie $n$ to liczba unikalnych liter w oryginalnym alfabecie. Nadal będziemy korzystać z litery testowej $t$ \\
Ustalimy więc konwencję zapisu, w której dla danego $a$ krawędź z etykietą $bin(a)$ reprezentuje ciąg stanów połączonych krawędziami o etykietach odpowiadających kolejnym bitom w kodzie binarnym $bin(a)$. Jeżeli mamy wiele krawędzi $bin$ wychodzących z tego samego wierzchołka, to ich krawędzie o tych samych etykietach stanowią tą samą krawędź. Na przykład, jeżeli mamy litery $a$ oraz $b$ reprezentowane przez $101$ oraz $100$, reprezentują one 4 krawędzie - najpierw ciąg dwóch, gdzie pierwsza ma etykietę $1$, a druga $0$ - następnie krawędzie $1$ oraz $0$ wychodzące z ostatniego wierzchołka (tak jak na rysunku \ref{fig:kclique-bin-example}). \\

\import{theory/figures}{reduction_kclique_bin_example}

\import{theory/figures}{reduction_kclique_3}

Idea działania oraz konstrukcja próbek pozostaje taka sama jak w przypadku alfabetu o rozmiarze $O(n)$, z tą różnicą, że każda krawędź jest teraz reprezentowana jako ciąg krawędzi zgodnie z powyższą konwencją. \\
W poniższym zapisie $bin(a)$ oznacza ciąg liter reprezentujący literę $a$ w kodzie binarnym.

\vspace{0.5cm}

%* zagwarantowanie że wybieramy stany v_i
\noindent \textbf{Gwarancja prowadzenia brakujących krawędzi do wierzchołków $v_i$}

Zagwarantowanie tego faktu opiera się na tej samej obserwacji co w przypadku alfabetu o rozmiarze $O(n)$. Aby próbka mogła zostać zaakceptowana, musimy dwukrotnie przejść przez krawędź $t$ - dodamy więc w każdej próbce literę $t$ po każdym wyborze wierzchołka $v_i$. \\
Dodatkowo nadal musimy zapobiec prowadzeniu brakujących krawędzi do stanu $\text{sink}_+$. Jak uprzednio, robimy to poprzez liczenie ile razy przeszliśmy krawędzią $t$, lub poprzez dodanie próbek odrzucających:

\begin{equation}
\forall x\in\{1..k\} \ {[bin(x) \ 0] \in S^-}
\label{eq:kclique-3-sink}
\end{equation}

%* zagwarantowanie że wybrane stany v_i są różne
\noindent \textbf{Wybór różnych stanów $v_i$ dla różnych brakujących krawędzi}
\begin{equation}
\forall (x, y \in \{1..k\} \land x \neq y) \ \forall i \in \{1..n\} \ {[bin(x) \ 0 \ t \ bin(i) \ 0 \ bin(y) \ 0 \ t \ bin(i) \ 0]  \in S^+}
\label{eq:kclique-3-diff}
\end{equation}

%* zagwarantowanie że wybrane wierzchołki tworzą klikę
\noindent \textbf{Gwarancja, że wybrane wierzchołki tworzą klikę}
\begin{equation}
\forall (x, y \in \{1..k\} \land x \neq y) \ \forall{i, j \in \{1..n\}} \ [bin(x) \ 0 \ t \ bin(i) \ 0 \ bin(y) \ 0 \ t \ bin(j) \ 1 \ bin(i)] \in S^+
\label{eq:kclique-3-clique}
\end{equation}


\subsubsection{Dla $|\Sigma|=2$}
Rysunek \ref{fig:kclique2} przedstawia konstrukcję automatu dla redukcji z k-klik, korzystająca z alfabetu o rozmiarze 2. \\
Konstrukcja próbek dla zagwarantowania wyboru różnych stanów $v_i$ oraz zagwarantowania, że wybrane wierzchołki tworzą klikę pozostaje analogiczna do poprzednich. Nie posiadamy już litery testowej $t$, więc musimy zmodyfikować zagwarantowanie prowadzenia brakujących krawędzi do wierzchołków $v_i$. \\

\import{theory/figures}{reduction_kclique_2}

Nowa idea automatu (rysunek \ref{fig:kclique2}) opiera się na przypisywaniu literom wartości od 1 do $n$, a następnie kodowaniu ich w systemie unarnym. W ten sposób każda litera jest reprezentowana jako ciąg liter $0$. \\
W poniższym zapisie $un(a)$ oznacza reprezentację litery $a$ w kodzie unarnym. Aby rozróżniać przejścia literą $1$, będziemy je składać z różnych wielokrotności $1$. Dlategu ustalamy zapis $d * a$ jako powtórzenie litery $a$ dokładnie $d$ razy.

%* zagwarantowanie że wybieramy stany v_i
\noindent \textbf{Gwarancja prowadzenia brakujących krawędzi do wierzchołków $v_i$}
Zaczniemy od zagwarantowania, że brakujące krawędzie nie prowadzą do żadnego stanu akceptującego, w tym do stanu $\text{sink}_+$. \\

\begin{equation}
\forall x\in\{1..k\} \ {[un(x) \ 1] \in S^-}
\label{eq:kclique-2-sink}
\end{equation}

Nie mamy już litery testowej $t$, więc musimy zmodyfikować automat oraz próbki tak, aby wymusić przejście brakującą krawędzią do któregoś ze stanów $v_i$. Możemy zastąpić literę $t$ specjalnym ciągiem $10*1$, który nie prowadzi do $sink_-$. Wtedy ten sam ciąg $10*1$ wystąpi dwukrotnie w każdej próbce, zaraz po przejściu brakującą krawędzią. 

Weźmy dowolną próbkę \eqref{eq:kclique-2-clique}, oraz odpowiadające jej $x, y, i, j$. Jeżeli brakująca krawędź odpowiadająca stanowi $p_y$ nie prowadzi do żadnego ze stanów $v_.$, to nie istnieje żaden inny stan do którego mogłaby ona prowadzić - musi prowadzić do stanu, po którym następuje przejście $11*1$, jedyne takie przejścia to $v_.$ oraz $sink_+$. Jednak przejście do $sink_+$ zostało wykluczone próbką \eqref{eq:kclique-2-sink}, więc pozostaje tylko przejście do któregoś ze stanów $v_.$.

Jeżeli brakująca krawędzi odpowiadająca stanowi $p_x$ nie prowadzi do żadnego ze stanów $v_.$, to może prowadzić tylko do stanów po których następuje przejście $10*1$. Jedynymi takimi stanami są stany $v_.$, $\delta(v_., 1)$ oraz $sink_+$ (który został wykluczony próbką \eqref{eq:kclique-2-sink}). Przejście do stanu $\delta(v_., 1)$, a następnie kolejnymi literami z próbik - $un(i)$ doprowadzi nas do krawędzi $3*1$ lub $4*1$, natomiast w próbce występuje $2*1$, a po nim $un(y)$ - czyli litera $0$. To przejście zostanie więc zawszez odrzucone. Pozostaje więc tylko przejście do któregoś ze stanów $v_.$. \\

%* zagwarantowanie że wybrane stany v_i są różne
\noindent \textbf{Wybór różnych stanów $v_i$ dla różnych brakujących krawędzi}
\begin{equation}
\forall (x, y \in \{1..k\} \land x \neq y) \ \forall i \in \{1..n\} \ {[un(x) \ 11*1 \ un(i) \ 2*1 \ un(y) \ 11*1 \ un(i) \ 2*1]  \in S^+}
\label{eq:kclique-2-diff}
\end{equation}

%* zagwarantowanie że wybrane wierzchołki tworzą klikę
\noindent \textbf{Gwarancja, że wybrane wierzchołki tworzą klikę}
\begin{equation}
\forall (x, y \in \{1..k\} \land x \neq y) \ \forall{i, j \in \{1..n\}} \ [un(x) \ 11*1 \ un(i) \ 2*1 \ un(y) \ 12*1 \ un(j) \ 4*1 \ un(i) \ 1] \in S^+
\label{eq:kclique-2-clique}
\end{equation}



\subsection{W[2]-trudność}
% TODO
% Redukcja z k-set cover (bierzemy k setów do pokrycia) do naszego problemu


\subsection{Przynależność do W[P]}
% TODO

% Póki co tylko nan bazie luźnej definicji z wikipedii - nasz prolem jest w klacie problemów gdzie mamy zbiór S n elementów (wszystkie możliwe naprawienia przejść), a my chcemy wybrać podzbiór z k - tak aby jakaś własność została utrzymana (być zgodnym z próbkami). Chcemy móc zapisać nasz wybór jako k intów zapisanych binarnie. \\
% Wg tej lużnej definicji, możemy mieć podejrzenia że nasz problem przynależy do W[P].

