\section{Algorytm ze skokami (Jump Tables)}

Algorytm ze skokami stanowi optymalizację algorytmu pełnego przeszukiwania przestrzeni możliwych uzupełnień brakujących przejść deterministycznego automatu skończonego. Jego głównym celem jest zmniejszenie przestrzeni przeszukiwań poprzez eliminację powtarzalnych fragmentów symulacji próbek wejściowych.

Podstawową obserwacją wykorzystywaną przez algorytm jest fakt, że w trakcie przeszukiwania przestrzeni rozwiązań zmieniają się jedynie brakujące przejścia automatu, a brakujący automat dany na wejściu pozostaje niezmienny. W klasycznym podejściu brute force każda próba weryfikacji wymaga pełnej symulacji wszystkich próbek symbol po symbolu, co prowadzi do znacznej redundancji obliczeń.

W celu ograniczenia tego zjawiska algorytm wprowadza etap wstępnego przetwarzania w postaci tablic skoków. Dla każdej próbki oraz każdego stanu automatu obliczana jest informacja opisująca najdalszy fragment słowa, który może zostać przetworzony bez przechodzenia przez nieokreślone przejścia. Pozwala to na szybkie pomijanie fragmentów wejścia, które nie zależą od aktualnie testowanego uzupełnienia automatu.

\subsubsection{Budowa tablic skoków}

Tablice skoków budowane są niezależnie dla zbioru przykładów pozytywnych oraz negatywnych. Dla każdej próbki $w$ o długości maksymalnie $L$ konstruowana jest tablica $DP$, w której wpis $DP[i][q]$ opisuje efekt przetworzenia najdłuższego możliwego fragmentu 
próbki $w$, zaczynając od pozycji $i$ w stanie $q$, bez użycia brakujących przejść.


\begin{algorithm}[H]
\caption{Budowa tablic skoków}
\KwIn{Automat $A = (Q, \Sigma, \delta, q_0, F)$, zbiór próbek $S$}
\KwOut{Tablica skoków $JT$}

\ForEach{próbka $w \in S$}{
    $L \leftarrow |w|$\;
    Utwórz tablicę $DP[0 \ldots L][0 \ldots |Q|-1]$\;

    \ForEach{stan $q \in Q$}{
        $DP[L][q] \leftarrow (q, L)$\;
    }

    \For{$i \leftarrow L-1$ \KwTo $0$}{
        \ForEach{stan $q \in Q$}{
            \If{$\delta(q, w[i])$ jest nieokreślone}{
                $DP[i][q] \leftarrow (q, i)$\;
            }
            \Else{
                $q' \leftarrow \delta(q, w[i])$\;
                $DP[i][q] \leftarrow DP[i+1][q']$\;
            }
        }
    }
    Dodaj $DP$ do $JT$\;
}
\Return{$JT$}
\end{algorithm}

\subsubsection{Walidacja automatu z użyciem tablic skoków}

Po skonstruowaniu tablic skoków algorytm wykorzystuje je podczas walidacji każdego kandydata. Zamiast symulować próbki krok po kroku, algorytm wykonuje skoki pomiędzy pozycjami, aż napotka fragment zależny od brakującego przejścia.

\begin{algorithm}[H]
\caption{Walidacja automatu z wykorzystaniem tablic skoków}
\KwIn{Automat $A$, próbki $S$, tablica skoków $JT$, oczekiwany wynik $b$}
\KwOut{true jeśli automat jest zgodny z próbkami, false w przeciwnym razie}

\ForEach{próbka $w_i \in S$}{
    $q \leftarrow q_0$, $pos \leftarrow 0$\;
    \While{$pos < |w_i|$}{
        $(q', pos') \leftarrow JT[i][pos][q]$\;
        \If{$(q', pos') = (q, pos)$}{
            \If{$\delta(q, w_i[pos])$ jest nieokreślone}{
                Przerwij symulację tej próbki\;
            }
            $q \leftarrow \delta(q, w_i[pos])$\;
            $pos \leftarrow pos + 1$\;
        }
        \Else{
            $q \leftarrow q'$, $pos \leftarrow pos'$\;
        }
    }
    \If{$(q \in F) \neq b$}{
        \Return{false}\;
    }
}
\Return{true}
\end{algorithm}

\subsubsection{Integracja z algorytmem pełnego przeszukiwania}

Algorytm ze skokami nie modyfikuje samej strategii przeszukiwania przestrzeni możliwych uzupełnień brakujących przejść. Zastępuje on jedynie klasyczną procedurę walidacji automatu zoptymalizowaną wersją wykorzystującą tablice skoków. Dzięki temu zachowana zostaje pełna poprawność algorytmu brute force, przy jednoczesnym istotnym zmniejszeniu czasu weryfikacji pojedynczego kandydata w praktyce.

\subsection{Heurystyka naprawy automatu z losowymi restartami}

W celu praktycznego rozwiązania problemu naprawy brakujących przejść w deterministycznym automacie skończonym zastosowano heurystykę opartą na lokalnym przeszukiwaniu przestrzeni rozwiązań, uzupełnioną o mechanizm losowych restartów. Metoda ta ma na celu znalezienie automatu zgodnego ze wszystkimi przykładami pozytywnymi i negatywnymi, przy istotnie mniejszym koszcie obliczeniowym niż pełne przeszukiwanie metodą brutalną.

\subsubsection{Ocena poprawności próbek}

Podstawową operacją wykorzystywaną w algorytmie jest symulacja działania automatu na danej próbce wejściowej. Próbka uznawana jest za poprawnie sklasyfikowaną, jeżeli:
\begin{itemize}
    \item w trakcie symulacji nie zostanie napotkane brakujące przejście,
    \item automat zakończy działanie w stanie akceptującym dla próbki pozytywnej,
    \item automat zakończy działanie w stanie nieakceptującym dla próbki negatywnej.
\end{itemize}

\subsubsection{Hill Climbing}

Główna część heurystyki opiera się na algorytmie hill climbing, który iteracyjnie modyfikuje przejścia automatu w celu minimalizacji liczby błędnie sklasyfikowanych próbek.

W każdej iteracji algorytm:
\begin{enumerate}
    \item identyfikuje zbiór próbek błędnie sklasyfikowanych przez aktualny automat,
    \item dla każdej takiej próbki przechodzi przez kolejne symbole słowa,
    \item dla każdego przejścia testuje wszystkie możliwe stany docelowe,
    \item wybiera przejście minimalizujące całkowitą liczbę błędnych klasyfikacji.
\end{enumerate}

Jeżeli w danej iteracji nie nastąpi żadna poprawa, algorytm kończy działanie, uznając, że osiągnięto minimum lokalne.

\subsubsection{Losowe restarty}

Ponieważ algorytm hill climbing może zatrzymać się w minimum lokalnym, zastosowano mechanizm losowych restartów. Każdy restart polega na:
\begin{itemize}
    \item przywróceniu wybrakowanego automatu do stanu początkowego,
    \item losowej inicjalizacji wszystkich brakujących przejść,
    \item ponownym uruchomieniu procedury hill climbing.
\end{itemize}

Jeżeli w trakcie któregoś restartu zostanie znaleziony automat zgodny ze wszystkimi próbkami, algorytm kończy działanie sukcesem.

\subsubsection{Złożoność obliczeniowa}

Niech:
\begin{itemize}
    \item $n$ oznacza liczbę stanów automatu,
    \item $m$ maksymalną długość próbki,
    \item $|S|$ łączną liczbę próbek,
    \item $I$ maksymalną liczbę iteracji hill climbing,
    \item $R$ liczbę losowych restartów.
\end{itemize}

Złożoność heurystyki z losowymi restartami wynosi:
\[
\mathcal{O}(R \cdot I \cdot |S| \cdot m \cdot n),
\]
co w praktyce pozwala na znaczące przyspieszenie względem algorytmu brutalnego kosztem braku gwarancji znalezienia rozwiązania optymalnego.

\subsubsection{Pseudokod algorytmu}

\begin{algorithm}[H]
\caption{Heurystyczna naprawa automatu z losowymi restartami}
\KwIn{Wybrakowany automat $A = (Q,\Sigma,\delta,q_0,F)$, próbki pozytywne $S^+$, próbki negatywne $S^-$}
\KwOut{Naprawiony automat $A'$ lub informacja o niepowodzeniu}

\For{$r \leftarrow 1$ \KwTo $R$}{
    $A_r \leftarrow A$\;
    Losowo uzupełnij wszystkie brakujące przejścia w $A_r$\;

    \For{$i \leftarrow 1$ \KwTo $I$}{
        $invalid \leftarrow \{w \in S^+ \cup S^- \mid A_r \text{ błędnie klasyfikuje } w\}$\;

        \If{$invalid = \emptyset$}{
            \Return{$A_r$}
        }

        $any\_change \leftarrow false$\;

        \ForEach{$w \in invalid$}{
            $q \leftarrow q_0$\;

            \For{$j \leftarrow 0$ \KwTo $|w|-1$}{
                $a \leftarrow w[j]$\;
                $q_{\text{old}} \leftarrow \delta(q,a)$\;
                $best \leftarrow q_{\text{old}}$\;
                $best\_errors \leftarrow |invalid|$\;

                \ForEach{$p \in Q$}{
                    \If{$p \neq q_{\text{old}}$}{
                        tymczasowo ustaw $\delta(q,a) \leftarrow p$\;
                        $errors \leftarrow$ liczba błędnie sklasyfikowanych próbek z $S^+ \cup S^-$\;

                        \If{$errors < best\_errors$}{
                            $best \leftarrow p$\;
                            $best\_errors \leftarrow errors$\;
                        }
                    }
                }

                ustaw $\delta(q,a) \leftarrow best$\;

                \If{$best \neq q_{\text{old}}$}{
                    $any\_change \leftarrow true$\;
                }

                $q \leftarrow best$\;
            }
        }

        \If{$any\_change = false$}{
            \textbf{przerwij}
        }
    }
}

\Return{\textbf{niepowodzenie}}
\end{algorithm}
