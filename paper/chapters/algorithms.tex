\section{Podejście Brute Force}

Podejście brute force polega na systematycznym sprawdzaniu wszystkich możliwych sposobów uzupełnienia brakujących przejść w automacie. Algorytm generuje kolejne warianty automatu poprzez przypisywanie stanów brakującym przejściom dla poszczególnych symboli alfabetu.

Każdy taki wariant traktowany jest jako osobny kandydat rozwiązania problemu. Dla wygenerowanego automatu algorytm symuluje następnie przetwarzanie wszystkich próbek, przechodząc krok po kroku przez kolejne stany zgodnie z symbolami próbek. Po zakończeniu symulacji sprawdzane jest, czy każda z próbek kończy się w stanie zgodnym z danymi wejściowymi.

Jeżeli dla danego wariantu automatu warunek ten nie jest spełniony, algorytm odrzuca go i przechodzi do analizy kolejnej kombinacji uzupełnień. Proces ten jest powtarzany aż do momentu znalezienia pierwszego wariantu, dla którego wszystkie próbki są poprawnie obsługiwane. W tym momencie algorytm kończy działanie.


\subsubsection{Złożoność obliczeniowa}
Czas algorytmu wynosi $\mathcal{O}(N^k \cdot M \cdot |S|)$, gdzie $N$ to liczba stanów, $k$ to liczba brakujących przejść, $M$ to maksymalna długość próbki, a $|S|$ to liczba próbek.

\section{Algorytm ze skokami (Jump Tables)}

Algorytm ze skokami stanowi optymalizację symulacji przechodzenia próbką po automacie, z algorytmu Brute Force. Jego głównym celem jest zredukowanie liczby krawędzi, które muszą być przetworzone podczas weryfikacji próbki z automatem. \\
Możemy zaobserwować, że przechodzenie po \textit{znanych} krawędziach - czyli takich przejściach które dostaliśmy na wejściu - może często prowadzić do redundantnych obliczeń, ponieważ występują one często w automacie, a utworzone z nich ścieżki są jednoznacznie określone dla dowolnej wersji naprawionego automatu.

Dlatego też konstrukcja algorytmu opiera się na stworzeniu struktury, która dla każdego możliwego sufiksu próbek oraz każdego stanu automatu, pozwala na natychmiastowe wyznaczenie stanu docelowego - osiągalnego przy użyciu wyłącznie znanych krawędzi, przeskakując przy tym możliwie najdłuższy fragment podanego sufiksu. \\
Do algorytmu wprowadzany jest etap wstępnego przetwarzania, gdzieopisana struktura jest wyliczana w postaci tablic skoków. Następnie, podczas walidacji automatu, przechodząc próbką po automacie korzystamy z tablicy skoków, aby przeskoczyć fragmenty składające się ze \textit{znanych} krawędzi. 

W efekcie wykonamy jedynie tyle kroków, ile jest \textit{brakujących} krawędzi na ścieżce odpowiadającej danej próbce w automacie.

\subsubsection{Budowa tablic skoków}

Tablice skoków budowane są niezależnie dla zbioru przykładów pozytywnych oraz negatywnych. Dla każdej próbki $w$ o długości maksymalnie $L$ konstruowana jest tablica $DP$, w której wpis $DP[i][q]$ opisuje efekt przetworzenia najdłuższego możliwego fragmentu 
próbki $w$, zaczynając od pozycji $i$ w stanie $q$, bez użycia brakujących przejść.


\begin{algorithm}[H]
\caption{Budowa tablic skoków}
\KwIn{Automat $A = (Q, \Sigma, \delta, q_0, F)$, zbiór próbek $S$}
\KwOut{Tablica skoków $JT$}

\ForEach{próbka $w \in S$}{
    $L \leftarrow |w|$\;
    Utwórz tablicę $DP[0 \ldots L][0 \ldots |Q|-1]$\;

    \ForEach{stan $q \in Q$}{
        $DP[L][q] \leftarrow (q, L)$\;
    }

    \For{$i \leftarrow L-1$ \KwTo $0$}{
        \ForEach{stan $q \in Q$}{
            \If{$\delta(q, w[i])$ jest nieokreślone}{
                $DP[i][q] \leftarrow (q, i)$\;
            }
            \Else{
                $q' \leftarrow \delta(q, w[i])$\;
                $DP[i][q] \leftarrow DP[i+1][q']$\;
            }
        }
    }
    Dodaj $DP$ do $JT$\;
}
\Return{$JT$}
\end{algorithm}

\subsubsection{Walidacja automatu z użyciem tablic skoków}

Po skonstruowaniu tablic skoków algorytm wykorzystuje je podczas walidacji każdego kandydata. Zamiast symulować próbki krok po kroku, algorytm wykonuje skoki pomiędzy pozycjami, aż napotka fragment zależny od brakującego przejścia.

\begin{algorithm}[H]
\caption{Walidacja automatu z wykorzystaniem tablic skoków}
\KwIn{Automat $A$, próbki $S$, tablica skoków $JT$, oczekiwany wynik $b$}
\KwOut{true jeśli automat jest zgodny z próbkami, false w przeciwnym razie}

\ForEach{próbka $w_i \in S$}{
    $q \leftarrow q_0$, $pos \leftarrow 0$\;
    \While{$pos < |w_i|$}{
        $(q', pos') \leftarrow JT[i][pos][q]$\;
        \If{$(q', pos') = (q, pos)$}{
            \If{$\delta(q, w_i[pos])$ jest nieokreślone}{
                Przerwij symulację tej próbki\;
            }
            $q \leftarrow \delta(q, w_i[pos])$\;
            $pos \leftarrow pos + 1$\;
        }
        \Else{
            $q \leftarrow q'$, $pos \leftarrow pos'$\;
        }
    }
    \If{$(q \in F) \neq b$}{
        \Return{false}\;
    }
}
\Return{true}
\end{algorithm}

\subsubsection{Integracja z algorytmem pełnego przeszukiwania}
% TODO integracja z (prawie) dowolnym algorytmem
% tą optymalizację możemy potraktować jako przekształcenie automatu w taki, który nadal jest w stanie chodzić po wszystkich próbkach zadanych na wejściu, ale teraz dodatkowo posiada krawędzie etykietowane podsłowami, którymi moze przejść w O(1)

Algorytm ze skokami nie modyfikuje samej strategii przeszukiwania przestrzeni możliwych uzupełnień brakujących przejść. Zastępuje on jedynie klasyczną procedurę walidacji automatu zoptymalizowaną wersją wykorzystującą tablice skoków. Dzięki temu zachowana zostaje pełna poprawność algorytmu brute force, przy jednoczesnym istotnym zmniejszeniu czasu weryfikacji pojedynczego kandydata w praktyce.


\subsubsection{Analiza wydajności}
Czas budowy tablic skoków wynosi $\mathcal{O}(|S| \cdot M \cdot N)$, gdzie $|S|$ to liczba próbek, $M$ to maksymalna długość próbki, a $N$ to liczba stanów automatu.

% TODO - elaborate; maybe drawing of example problematic case?
Z założeń wynika, że przy walidacji próbki wykonamy tyle kroków, ile jest brakujących przejść na ścieżce odpowiadającej danej próbce w automacie. W najgorszym przypadku, gdy wszystkie przejścia są brakujące lub co drugie przejście jest brakujące, czas walidacji pozostaje $\mathcal{O}(M)$.
W praktyce jednak, dla automatu z niewielką liczbą brakujących przejść, czas ten może być znacznie mniejszy.

\section{Heurystyka naprawy automatu z losowymi restartami}

Algorytm hill climbing \cite{hill_climbing} jest algorytmem, który rozpoczyna działanie od pewnego początkowego rozwiązania, a następnie iteracyjnie wprowadza niewielkie modyfikacje, dążąc do poprawy wartości funkcji celu. W każdej iteracji rozważane są rozwiązania sąsiednie, różniące się od aktualnego jedynie pojedynczą zmianą, w tym przypadku: przypisaniem innego stanu docelowego do jednego przejścia automatu. Jeżeli taka modyfikacja prowadzi do poprawy wartości funkcji celu, w tym przypadku: więcej próbek osiąga docelowy stan zgodny z danymi wejściowymi, jest ona akceptowana jako nowe rozwiązanie bieżące.

Metoda ta jest podatna na zatrzymanie się w minimach lokalnych, ponieważ algorytm akceptuje jedynie zmiany prowadzące do poprawy rozwiązania. W celu ograniczenia tego problemu zastosowano losowe restarty algorytmu. Po osiągnięciu minimum lokalnego, w którym nie istnieje żadna poprawiająca modyfikacja, algorytm rozpoczyna działanie od nowej, losowo wygenerowanej konfiguracji niezidentyfikowanych przejśc automatu. Proces ten jest powtarzany wielokrotnie, co zwiększa prawdopodobieństwo odnalezienia rozwiązania.

\section{Pruning przestrzeni rozwiązań}

W celu ograniczenia liczby analizowanych konfiguracji automatu
zastosowano mechanizm odcinania nieperspektywicznych gałęzi przeszukiwań
(pruning). Podstawową obserwacją jest fakt, że częściowe ustalenie
przejść automatu zawęża zbiór wszystkich możliwych poprawnych
konfiguracji.

W trakcie działania algorytmu utrzymywany jest zbiór potencjalnie
poprawnych automatów, zgodnych z dotychczas ustalonymi przejściami.
Każde przypisanie stanu do kolejnego brakującego przejścia powoduje
zawężenie tego zbioru poprzez odrzucenie wszystkich konfiguracji, które
nie spełniają nowo wprowadzonego ograniczenia.

Jeżeli na pewnym etapie, przy częściowo ustalonym automacie, zbiór
potencjalnych konfiguracji staje się pusty, oznacza to, że żadna
kompletna konfiguracja automatu zgodna z danymi wejściowymi nie może
powstać w danym kierunku dalszej eksploracji. W takiej sytuacji algorytm
przerywa dalsze rozważanie tej gałęzi, niezależnie od tego, że nie
wszystkie przejścia zostały jeszcze ustalone.

Zastosowanie pruningu pozwala uniknąć dalszego rozpatrywania konfiguracji,
które z góry nie mogą prowadzić do poprawnego rozwiązania, co znacząco
redukuje liczbę analizowanych przypadków.

\section{Wykorzystanie struktury trie}

W celu ograniczenia wielokrotnego przetwarzania tych samych prefiksów
próbek zastosowano strukturę drzewa trie. Wszystkie próbki wejściowe
zostały przekształcone do postaci jednego drzewa, w którym każda krawędź
odpowiada pojedynczemu symbolowi alfabetu, a ścieżki od korzenia do węzłów
reprezentują prefiksy próbek.

Dzięki takiej reprezentacji wspólne prefiksy próbek są przetwarzane tylko
raz. Zamiast wielokrotnego przechodzenia tych samych przejść automatu dla
każdej próbki osobno, algorytm wykonuje jedno przejście dla danego
prefiksu, a następnie kontynuuje przetwarzanie dla wszystkich próbek,
które ten prefiks współdzielą.

Algorytm nie symuluje więc każdej próbki niezależnie, lecz eksploruje
strukturę drzewa trie, odwiedzając kolejne węzły i odpowiadające im
przejścia automatu. W ten sposób eliminowane jest powtarzające się
przechodzenie tych samych krawędzi automatu, co prowadzi do istotnej
redukcji liczby wykonywanych operacji, szczególnie w przypadku dużej
liczby próbek o wspólnych prefiksach.

\section{Backtracking z wykorzystaniem skoków}

Backtracking jest metodą przeszukiwania polegającą na stopniowym
konstruowaniu rozwiązania poprzez podejmowanie kolejnych decyzji oraz
cofanie się do wcześniejszych kroków w momencie, gdy dalsza eksploracja
danego kierunku nie może prowadzić do poprawnego rozwiązania. Podejście
to umożliwia systematyczne badanie możliwych uzupełnień automatu przy
jednoczesnym odrzucaniu nieperspektywicznych konfiguracji na możliwie
wczesnym etapie.

W rozważanym algorytmie backtracking wykorzystywany jest w połączeniu z
mechanizmem skoków pomiędzy zapamiętanymi przejściami automatu. Dzięki
temu algorytm nie rozpoczyna symulacji próbek od początku po każdej
modyfikacji, lecz kontynuuje przetwarzanie od ostatniego poprawnie
zdefiniowanego przejścia, co znacząco redukuje liczbę powtarzanych
operacji.

Algorytm analizuje próbki pojedynczo i dla aktualnie rozpatrywanej
próbki identyfikuje pierwsze brakujące przejście napotkane podczas jej
symulacji. Wybrane przejście staje się kolejną decyzją do ustalenia, a
algorytm przypisuje mu kolejno możliwe stany docelowe. Po każdej
modyfikacji kontynuowana jest symulacja próbki z wykorzystaniem
mechanizmu skoków.

Jeżeli w trakcie dalszego przetwarzania okaże się, że aktualna
konfiguracja automatu nie pozwala doprowadzić próbki do stanu zgodnego z
danymi wejściowymi, algorytm cofa ostatnią decyzję i próbuje kolejnego
możliwego przypisania. Proces ten jest powtarzany aż do znalezienia
poprawnej konfiguracji automatu lub wyczerpania wszystkich możliwych
kombinacji, co skutkuje powrotem do wcześniejszych etapów przeszukiwania.



