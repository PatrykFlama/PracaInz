\section{Podejście Brute Force}

Podejście brute force polega na sprawdzeniu całej przestrzeni przeszukiwań, tzn. zapełnienia brakujących przejść w automacie każą możliwą kombinacją, a następnie zasymulowania każdej z próbek i sprawdzeniu czy kończy w stanie zgodnym z danymi wejściowymi. Algorytm kończy działanie w momencie znalezienia właściwej kombinacji.

\subsubsection{Złożoność obliczeniowa}
Czas algorytmu wynosi $\mathcal{O}(N^k \cdot M \cdot |S|)$, gdzie $N$ to liczba stanów, $k$ to liczba brakujących przejść, $M$ to maksymalna długość próbki, a $|S|$ to liczba próbek.

\section{Algorytm ze skokami (Jump Tables)}

Algorytm ze skokami stanowi optymalizację symulacji przechodzenia próbką po automacie, z algorytmu Brute Force. Jego głównym celem jest zredukowanie liczby krawędzi, które muszą być przetworzone podczas weryfikacji próbki z automatem. \\
Możemy zaobserwować, że przechodzenie po \textit{znanych} krawędziach - czyli takich przejściach które dostaliśmy na wejściu - może często prowadzić do redundantnych obliczeń, ponieważ występują one często w automacie, a utworzone z nich ścieżki są jednoznacznie określone dla dowolnej wersji naprawionego automatu.

Dlatego też konstrukcja algorytmu opiera się na stworzeniu struktury, która dla każdego możliwego sufiksu próbek oraz każdego stanu automatu, pozwala na natychmiastowe wyznaczenie stanu docelowego - osiągalnego przy użyciu wyłącznie znanych krawędzi, przeskakując przy tym możliwie najdłuższy fragment podanego sufiksu. \\
Do algorytmu wprowadzany jest etap wstępnego przetwarzania, gdzieopisana struktura jest wyliczana w postaci tablic skoków. Następnie, podczas walidacji automatu, przechodząc próbką po automacie korzystamy z tablicy skoków, aby przeskoczyć fragmenty składające się ze \textit{znanych} krawędzi. 

W efekcie wykonamy jedynie tyle kroków, ile jest \textit{brakujących} krawędzi na ścieżce odpowiadającej danej próbce w automacie.

\subsubsection{Budowa tablic skoków}

Tablice skoków budowane są niezależnie dla zbioru przykładów pozytywnych oraz negatywnych. Dla każdej próbki $w$ o długości maksymalnie $L$ konstruowana jest tablica $DP$, w której wpis $DP[i][q]$ opisuje efekt przetworzenia najdłuższego możliwego fragmentu 
próbki $w$, zaczynając od pozycji $i$ w stanie $q$, bez użycia brakujących przejść.


\begin{algorithm}[H]
\caption{Budowa tablic skoków}
\KwIn{Automat $A = (Q, \Sigma, \delta, q_0, F)$, zbiór próbek $S$}
\KwOut{Tablica skoków $JT$}

\ForEach{próbka $w \in S$}{
    $L \leftarrow |w|$\;
    Utwórz tablicę $DP[0 \ldots L][0 \ldots |Q|-1]$\;

    \ForEach{stan $q \in Q$}{
        $DP[L][q] \leftarrow (q, L)$\;
    }

    \For{$i \leftarrow L-1$ \KwTo $0$}{
        \ForEach{stan $q \in Q$}{
            \If{$\delta(q, w[i])$ jest nieokreślone}{
                $DP[i][q] \leftarrow (q, i)$\;
            }
            \Else{
                $q' \leftarrow \delta(q, w[i])$\;
                $DP[i][q] \leftarrow DP[i+1][q']$\;
            }
        }
    }
    Dodaj $DP$ do $JT$\;
}
\Return{$JT$}
\end{algorithm}

\subsubsection{Walidacja automatu z użyciem tablic skoków}

Po skonstruowaniu tablic skoków algorytm wykorzystuje je podczas walidacji każdego kandydata. Zamiast symulować próbki krok po kroku, algorytm wykonuje skoki pomiędzy pozycjami, aż napotka fragment zależny od brakującego przejścia.

\begin{algorithm}[H]
\caption{Walidacja automatu z wykorzystaniem tablic skoków}
\KwIn{Automat $A$, próbki $S$, tablica skoków $JT$, oczekiwany wynik $b$}
\KwOut{true jeśli automat jest zgodny z próbkami, false w przeciwnym razie}

\ForEach{próbka $w_i \in S$}{
    $q \leftarrow q_0$, $pos \leftarrow 0$\;
    \While{$pos < |w_i|$}{
        $(q', pos') \leftarrow JT[i][pos][q]$\;
        \If{$(q', pos') = (q, pos)$}{
            \If{$\delta(q, w_i[pos])$ jest nieokreślone}{
                Przerwij symulację tej próbki\;
            }
            $q \leftarrow \delta(q, w_i[pos])$\;
            $pos \leftarrow pos + 1$\;
        }
        \Else{
            $q \leftarrow q'$, $pos \leftarrow pos'$\;
        }
    }
    \If{$(q \in F) \neq b$}{
        \Return{false}\;
    }
}
\Return{true}
\end{algorithm}

\subsubsection{Integracja z algorytmem pełnego przeszukiwania}
% TODO integracja z (prawie) dowolnym algorytmem
% tą optymalizację możemy potraktować jako przekształcenie automatu w taki, który nadal jest w stanie chodzić po wszystkich próbkach zadanych na wejściu, ale teraz dodatkowo posiada krawędzie etykietowane podsłowami, którymi moze przejść w O(1)

Algorytm ze skokami nie modyfikuje samej strategii przeszukiwania przestrzeni możliwych uzupełnień brakujących przejść. Zastępuje on jedynie klasyczną procedurę walidacji automatu zoptymalizowaną wersją wykorzystującą tablice skoków. Dzięki temu zachowana zostaje pełna poprawność algorytmu brute force, przy jednoczesnym istotnym zmniejszeniu czasu weryfikacji pojedynczego kandydata w praktyce.


\subsubsection{Analiza wydajności}
Czas budowy tablic skoków wynosi $\mathcal{O}(|S| \cdot M \cdot N)$, gdzie $|S|$ to liczba próbek, $M$ to maksymalna długość próbki, a $N$ to liczba stanów automatu.

% TODO - elaborate; maybe drawing of example problematic case?
Z założeń wynika, że przy walidacji próbki wykonamy tyle kroków, ile jest brakujących przejść na ścieżce odpowiadającej danej próbce w automacie. W najgorszym przypadku, gdy wszystkie przejścia są brakujące lub co drugie przejście jest brakujące, czas walidacji pozostaje $\mathcal{O}(M)$.
W praktyce jednak, dla automatu z niewielką liczbą brakujących przejść, czas ten może być znacznie mniejszy.

\section{Heurystyka naprawy automatu z losowymi restartami}

Heurystyka oparta jest na algorytmie hill climbing \cite{hill_climbing} z losowymi restartami, w którym każda modyfikacja przejścia automatu oceniana jest poprzez globalną funkcję celu równą liczbie próbek naruszających specyfikację wejściową.
